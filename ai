import java.util.concurrent.*;

public class AsyncRetry {

  private final ScheduledExecutorService scheduler;

  public AsyncRetry(ScheduledExecutorService scheduler) {
    this.scheduler = scheduler;
  }

  // convenience default ctor (prod)
  public AsyncRetry() {
    this(Executors.newScheduledThreadPool(1));
  }

  public <T> CompletableFuture<T> retryAsync(
      Callable<CompletableFuture<T>> action,
      int maxAttempts,
      long baseDelayMs
  ) {
    CompletableFuture<T> promise = new CompletableFuture<>();
    attempt(action, maxAttempts, 1, baseDelayMs, promise);
    return promise;
  }

  private <T> void attempt(Callable<CompletableFuture<T>> action,
                           int maxAttempts,
                           int attempt,
                           long baseDelayMs,
                           CompletableFuture<T> promise) {
    try {
      action.call().whenComplete((res, ex) -> {
        if (ex == null) {
          promise.complete(res);
          return;
        }

        if (attempt >= maxAttempts || !isRetriable(ex)) {
          promise.completeExceptionally(ex);
          return;
        }

        long delay = baseDelayMs * (1L << (attempt - 1)); // 500, 1000, 2000...
        scheduler.schedule(() -> attempt(action, maxAttempts, attempt + 1, baseDelayMs, promise),
            delay, TimeUnit.MILLISECONDS);
      });
    } catch (Exception e) {
      promise.completeExceptionally(e);
    }
  }

  // keep same logic as your version
  boolean isRetriable(Throwable ex) {
    Throwable root = ex instanceof CompletionException ? ex.getCause() : ex;
    return root instanceof org.apache.kafka.common.errors.TimeoutException
        || root instanceof org.apache.kafka.common.errors.NetworkException
        || root instanceof org.apache.kafka.common.errors.NotLeaderOrFollowerException
        || root instanceof org.apache.kafka.common.errors.LeaderNotAvailableException;
  }
}