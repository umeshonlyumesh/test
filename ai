
package com.truist.cps.kafka.monitor;

import com.truist.cps.kafka.config.KafkaSdkProperties;
import com.truist.cps.kafka.notification.SdkNotifier;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.admin.*;
import org.apache.kafka.clients.consumer.OffsetAndMetadata;
import org.apache.kafka.common.TopicPartition;
import org.springframework.scheduling.annotation.Scheduled;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@RequiredArgsConstructor
public class LagMonitor {

    private final AdminClient adminClient;
    private final KafkaSdkProperties props;
    private final SdkNotifier notifier;

    // To prevent alert spam
    private final Map<String, Long> lastNotified = new ConcurrentHashMap<>();

    @Scheduled(fixedDelayString = "#{@kafkaSdkProperties.lag.checkIntervalMs}")
    public void checkLag() {

        if (!props.getLag().isEnabled()) {
            return;
        }

        String groupId = props.getGroupId();
        long threshold = props.getLag().getThreshold();
        long cooldown = props.getLag().getNotifyCooldownMs();

        try {
            // 1️⃣ Get committed offsets
            Map<TopicPartition, OffsetAndMetadata> committed =
                    adminClient.listConsumerGroupOffsets(groupId)
                            .partitionsToOffsetAndMetadata()
                            .get();

            if (committed.isEmpty()) {
                return;
            }

            // 2️⃣ Get latest offsets
            Map<TopicPartition, OffsetSpec> request = new HashMap<>();
            committed.keySet().forEach(tp -> request.put(tp, OffsetSpec.latest()));

            Map<TopicPartition, ListOffsetsResult.ListOffsetsResultInfo> latest =
                    adminClient.listOffsets(request)
                            .all()
                            .get();

            // 3️⃣ Calculate lag
            for (Map.Entry<TopicPartition, OffsetAndMetadata> entry : committed.entrySet()) {

                TopicPartition tp = entry.getKey();
                long committedOffset = entry.getValue().offset();
                long latestOffset = latest.get(tp).offset();

                long lag = Math.max(0, latestOffset - committedOffset);

                if (lag > threshold) {
                    log.warn("Lag exceeded topic={} partition={} lag={} threshold={}",
                            tp.topic(), tp.partition(), lag, threshold);

                    notifyIfAllowed(tp, lag, threshold, cooldown);
                }
            }

        } catch (Exception e) {
            log.error("Lag monitor failed", e);
        }
    }

    private void notifyIfAllowed(TopicPartition tp,
                                 long lag,
                                 long threshold,
                                 long cooldownMs) {

        String key = tp.topic() + "-" + tp.partition();
        long now = System.currentTimeMillis();

        Long last = lastNotified.get(key);

        if (last == null || now - last > cooldownMs) {
            notifier.onLagThresholdExceeded(tp.topic(), tp.partition(), lag, threshold);
            lastNotified.put(key, now);
        }
    }
}