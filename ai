limport com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.nio.charset.StandardCharsets;
import java.util.LinkedHashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AlertConsumerTest {

    private ObjectMapper objectMapper;

    @Mock private AlertValidator alertValidator;
    @Mock private ValidationProperties validationProperties;
    @Mock private RequestBuilder requestBuilder;
    @Mock private OrchestratorExecutor executor;

    private AlertConsumer consumer;

    @BeforeEach
    void setup() {
        objectMapper = new ObjectMapper();

        // create consumer with real ObjectMapper + mocks
        consumer = new AlertConsumer(
                objectMapper,
                alertValidator,
                validationProperties,
                requestBuilder,
                executor
        );
    }

    @Test
    void listen_whenJsonStringValid_shouldValidateBuildAndOrchestrate() throws Exception {
        // given
        CoreIntegrationRequest req = buildRequest(OperationType.CustomerAlert.name(), "REQ-1");
        String json = objectMapper.writeValueAsString(req);

        ConsumerRecord<String, Object> rec =
                new ConsumerRecord<>("topic", 0, 10L, "k1", json);

        OrchestratedRequest orchestrated = mock(OrchestratedRequest.class);
        when(requestBuilder.prepareRequest(any(CoreIntegrationRequest.class))).thenReturn(orchestrated);

        // when
        consumer.listen(rec);

        // then
        ArgumentCaptor<CoreIntegrationRequest> captor = ArgumentCaptor.forClass(CoreIntegrationRequest.class);
        verify(alertValidator, times(1)).validate(captor.capture(), eq(validationProperties));
        assertEquals("REQ-1", captor.getValue().getHeader().getRequestId());

        verify(requestBuilder, times(1)).prepareRequest(any(CoreIntegrationRequest.class));
        verify(executor, times(1)).orchestrate(orchestrated);
        verifyNoMoreInteractions(executor);
    }

    @Test
    void listen_whenAlreadyCoreIntegrationRequest_shouldProcessWithoutJsonParse() {
        // given
        CoreIntegrationRequest req = buildRequest(OperationType.CustomerAlert.name(), "REQ-2");

        ConsumerRecord<String, Object> rec =
                new ConsumerRecord<>("topic", 0, 11L, "k2", req);

        OrchestratedRequest orchestrated = mock(OrchestratedRequest.class);
        when(requestBuilder.prepareRequest(any(CoreIntegrationRequest.class))).thenReturn(orchestrated);

        // when
        consumer.listen(rec);

        // then
        verify(alertValidator, times(1)).validate(any(CoreIntegrationRequest.class), eq(validationProperties));
        verify(requestBuilder, times(1)).prepareRequest(any(CoreIntegrationRequest.class));
        verify(executor, times(1)).orchestrate(orchestrated);
    }

    @Test
    void listen_whenMapPayload_shouldConvertAndProcess() {
        // given (Map simulates LinkedHashMap from some JSON deserializer)
        Map<String, Object> header = new LinkedHashMap<>();
        header.put("operation", OperationType.CustomerAlert.name());
        header.put("requestId", "REQ-3");

        Map<String, Object> body = new LinkedHashMap<>();
        body.put("header", header);

        ConsumerRecord<String, Object> rec =
                new ConsumerRecord<>("topic", 0, 12L, "k3", body);

        OrchestratedRequest orchestrated = mock(OrchestratedRequest.class);
        when(requestBuilder.prepareRequest(any(CoreIntegrationRequest.class))).thenReturn(orchestrated);

        // when
        consumer.listen(rec);

        // then
        verify(alertValidator, times(1)).validate(any(CoreIntegrationRequest.class), eq(validationProperties));
        verify(executor, times(1)).orchestrate(orchestrated);
    }

    @Test
    void listen_whenInvalidOperation_shouldNotOrchestrate() {
        // given
        CoreIntegrationRequest req = buildRequest("SomeOtherOperation", "REQ-4");

        ConsumerRecord<String, Object> rec =
                new ConsumerRecord<>("topic", 0, 13L, "k4", req);

        // when
        consumer.listen(rec);

        // then
        verifyNoInteractions(alertValidator);
        verifyNoInteractions(requestBuilder);
        verifyNoInteractions(executor);
    }

    @Test
    void listen_whenHeaderNull_shouldNotOrchestrate() {
        // given
        CoreIntegrationRequest req = new CoreIntegrationRequest();
        req.setHeader(null);

        ConsumerRecord<String, Object> rec =
                new ConsumerRecord<>("topic", 0, 14L, "k5", req);

        // when
        consumer.listen(rec);

        // then
        verifyNoInteractions(alertValidator);
        verifyNoInteractions(requestBuilder);
        verifyNoInteractions(executor);
    }

    @Test
    void listen_whenBadJson_shouldNotOrchestrateAndNotThrow() {
        // given
        String badJson = "{not-valid-json";

        ConsumerRecord<String, Object> rec =
                new ConsumerRecord<>("topic", 0, 15L, "k6", badJson);

        // when / then (should not throw)
        assertDoesNotThrow(() -> consumer.listen(rec));

        verifyNoInteractions(alertValidator);
        verifyNoInteractions(requestBuilder);
        verifyNoInteractions(executor);
    }

    @Test
    void listen_whenJsonBytesValid_shouldProcess() throws Exception {
        // given
        CoreIntegrationRequest req = buildRequest(OperationType.CustomerAlert.name(), "REQ-7");
        byte[] bytes = objectMapper.writeValueAsBytes(req);

        ConsumerRecord<String, Object> rec =
                new ConsumerRecord<>("topic", 0, 16L, "k7", bytes);

        OrchestratedRequest orchestrated = mock(OrchestratedRequest.class);
        when(requestBuilder.prepareRequest(any(CoreIntegrationRequest.class))).thenReturn(orchestrated);

        // when
        consumer.listen(rec);

        // then
        verify(alertValidator, times(1)).validate(any(CoreIntegrationRequest.class), eq(validationProperties));
        verify(executor, times(1)).orchestrate(orchestrated);
    }

    // ---------------- helpers ----------------

    private CoreIntegrationRequest buildRequest(String operation, String requestId) {
        Header header = new Header();
        header.setOperation(operation);
        header.setRequestId(requestId);

        CoreIntegrationRequest req = new CoreIntegrationRequest();
        req.setHeader(header);
        return req;
    }
}