import org.apache.kafka.clients.producer.RecordMetadata;
import org.apache.kafka.common.TopicPartition;
import org.apache.kafka.common.errors.TimeoutException;
import org.junit.jupiter.api.Test;
import org.springframework.aop.framework.AopContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.retry.annotation.EnableRetry;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
import org.springframework.util.concurrent.SettableListenableFuture;

import java.time.Instant;
import java.util.concurrent.ExecutionException;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@SpringJUnitConfig(classes = RetryableKafkaClientTest.Cfg.class)
class RetryableKafkaClientTest {

    @TestConfiguration
    @EnableRetry
    static class Cfg {
        @Bean
        KafkaTemplate<String, Object> kafkaTemplate() {
            return mock(KafkaTemplate.class);
        }

        @Bean
        RetryableKafkaClient retryableKafkaClient(KafkaTemplate<String, Object> kafkaTemplate) {
            return new RetryableKafkaClient(kafkaTemplate);
        }
    }

    @Autowired
    KafkaTemplate<String, Object> kafkaTemplate;

    @Autowired
    RetryableKafkaClient client;

    @Test
    void sendWithRetry_successFirstAttempt_noRetry() throws Exception {
        // Arrange
        var future = new SettableListenableFuture<SendResult<String, Object>>();
        future.set(successSendResult("topicA", 0, 10L));

        when(kafkaTemplate.send(eq("topicA"), eq("k1"), any()))
                .thenReturn(future);

        // Act
        SendResult<String, Object> result = client.sendWithRetry("topicA", "k1", "payload");

        // Assert
        assertEquals("topicA", result.getRecordMetadata().topic());
        assertEquals(10L, result.getRecordMetadata().offset());

        verify(kafkaTemplate, times(1)).send(eq("topicA"), eq("k1"), any());
    }

    @Test
    void sendWithRetry_retriableTimeout_thenSuccess_retriesAndSucceeds() throws Exception {
        // Arrange: first call fails, second succeeds
        var futureFail = new SettableListenableFuture<SendResult<String, Object>>();
        futureFail.setException(new TimeoutException("temp timeout"));

        var futureOk = new SettableListenableFuture<SendResult<String, Object>>();
        futureOk.set(successSendResult("topicB", 1, 20L));

        when(kafkaTemplate.send(eq("topicB"), eq("k2"), any()))
                .thenReturn(futureFail)  // 1st attempt
                .thenReturn(futureOk);   // 2nd attempt

        // Act
        SendResult<String, Object> result = client.sendWithRetry("topicB", "k2", "payload");

        // Assert
        assertEquals("topicB", result.getRecordMetadata().topic());
        assertEquals(20L, result.getRecordMetadata().offset());

        verify(kafkaTemplate, times(2)).send(eq("topicB"), eq("k2"), any());
    }

    @Test
    void sendWithRetry_timeoutAlways_recoverCalledAndThrows() {
        // Arrange: always fail (maxAttempts=3 in your code)
        var f1 = new SettableListenableFuture<SendResult<String, Object>>();
        f1.setException(new TimeoutException("down"));

        var f2 = new SettableListenableFuture<SendResult<String, Object>>();
        f2.setException(new TimeoutException("down"));

        var f3 = new SettableListenableFuture<SendResult<String, Object>>();
        f3.setException(new TimeoutException("down"));

        when(kafkaTemplate.send(eq("topicC"), eq("k3"), any()))
                .thenReturn(f1)
                .thenReturn(f2)
                .thenReturn(f3);

        // Act + Assert
        RuntimeException ex = assertThrows(RuntimeException.class,
                () -> client.sendWithRetry("topicC", "k3", "payload"));

        assertTrue(ex.getMessage().toLowerCase().contains("permanently failed"));

        verify(kafkaTemplate, times(3)).send(eq("topicC"), eq("k3"), any());
    }

    // ---- helper ----
    private static SendResult<String, Object> successSendResult(String topic, int partition, long offset) {
        RecordMetadata rm = new RecordMetadata(
                new TopicPartition(topic, partition),
                0L,           // baseOffset
                offset,       // offset
                Instant.now().toEpochMilli(), // timestamp
                0,            // serializedKeySize
                0             // serializedValueSize
        );
        return new SendResult<>(null, rm);
    }
}