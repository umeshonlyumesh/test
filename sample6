package com.example.awssecrets;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.context.event.EventListener;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;
import org.springframework.util.CollectionUtils;

import java.time.Duration;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.*;

public class SecretsStartupLoader {

    private static final Logger log = LoggerFactory.getLogger(SecretsStartupLoader.class);

    private final SecretManagerService service;
    private final SecretsCache cache;
    private final AwsSecretsProperties props;

    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(r -> {
        Thread t = new Thread(r, "aws-secrets-refresh");
        t.setDaemon(true);
        return t;
    });

    public SecretsStartupLoader(SecretManagerService service, SecretsCache cache, AwsSecretsProperties props) {
        this.service = service;
        this.cache = cache;
        this.props = props;
    }

    @EventListener(ContextRefreshedEvent.class)
    public void onContextRefreshed(ContextRefreshedEvent e) {
        if (!props.isPreload()) return;
        if (!(e.getApplicationContext().getEnvironment() instanceof ConfigurableEnvironment env)) return;

        publishOnce(env);

        Duration refresh = props.getRefreshInterval();
        if (refresh != null && !refresh.isZero() && !refresh.isNegative()) {
            long secs = refresh.toSeconds();
            scheduler.scheduleAtFixedRate(() -> {
                try { publishOnce(env); }
                catch (Exception ex) { log.warn("Refresh failed: {}", ex.getMessage()); }
            }, secs, secs, TimeUnit.SECONDS);
        }
    }

    private void publishOnce(ConfigurableEnvironment env) {
        AwsSecretsProperties.Preload p = props.getPreloadSpec();
        if (p == null) return;

        Map<String, Object> combined = new HashMap<>();
        String prefix = (p.getPropertyPrefix() == null || p.getPropertyPrefix().isBlank())
                ? "" : p.getPropertyPrefix() + ".";

        if (!CollectionUtils.isEmpty(p.getTextKeys())) {
            for (String k : p.getTextKeys()) {
                Map<String,String> map = service.getSecret(k);
                map.forEach((kk, vv) -> combined.put(prefix + k.replace('/', '.')
                        + "." + kk, vv));
            }
        }
        if (!CollectionUtils.isEmpty(p.getBinaryKeys())) {
            for (String k : p.getBinaryKeys()) {
                byte[] data = service.getBinarySecret(k);
                combined.put(prefix + k.replace('/', '.') + ".binary", Base64.getEncoder().encodeToString(data));
            }
        }
        if (!CollectionUtils.isEmpty(p.getArns())) {
            for (String arn : p.getArns()) {
                Map<String,String> map = service.getSecretByArn(arn);
                map.forEach((kk, vv) -> combined.put(prefix + arnFragment(arn) + "." + kk, vv));
            }
        }

        if (!combined.isEmpty()) {
            env.getPropertySources().addLast(new MapPropertySource("aws-secrets", combined));
            log.info("Published {} AWS secret entries to Environment", combined.size());
        }
    }

    private String arnFragment(String arn) {
        // best-effort suffix (safe for use in property keys)
        int i = arn.lastIndexOf(':');
        return (i > 0 ? arn.substring(i + 1) : arn).replace('/', '.');
    }
}