package com.truist.core.pez.validation;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * SonarQube-clean unit tests for {@link QualificationValidation}.
 */
class QualificationValidationTest {

    private CoreIntegrationRequest request;
    private Header header;
    private ValidationProperties props;
    private Qualification qualification;
    private Enrichment enrichment;
    private PaymentInfo paymentInfo;

    @BeforeEach
    void setUp() {
        request = mock(CoreIntegrationRequest.class);
        header = mock(Header.class);
        props = mock(ValidationProperties.class);
        qualification = mock(Qualification.class);
        enrichment = mock(Enrichment.class);
        paymentInfo = mock(PaymentInfo.class);

        when(request.getQualification()).thenReturn(qualification);
        when(request.getHeader()).thenReturn(header);
        when(request.getPaymentInfo()).thenReturn(paymentInfo);
        when(qualification.getEnrichment()).thenReturn(enrichment);
        when(props.getSides()).thenReturn(java.util.List.of("CREDIT", "DEBIT"));
        when(enrichment.getSide()).thenReturn("CREDIT");
        when(paymentInfo.getPartyIdType()).thenReturn("Individual");
    }

    @Test
    void shouldThrowWhenQualificationIsNull() {
        when(request.getQualification()).thenReturn(null);

        ValidationException ex = assertThrows(
                ValidationException.class,
                () -> QualificationValidation.qualificationValidation(request, header, props)
        );

        assertTrue(ex.getMessage().contains("QUALIFICATION_INFO_ERROR"));
    }

    @Test
    void shouldThrowWhenEnrichmentIsNull() {
        when(qualification.getEnrichment()).thenReturn(null);

        ValidationException ex = assertThrows(
                ValidationException.class,
                () -> QualificationValidation.qualificationValidation(request, header, props)
        );

        assertTrue(ex.getMessage().contains("QUALIFICATION_INFO_ERROR"));
    }

    @Test
    void shouldThrowWhenSideIsInvalid() {
        when(enrichment.getSide()).thenReturn("INVALID");

        ValidationException ex = assertThrows(
                ValidationException.class,
                () -> QualificationValidation.qualificationValidation(request, header, props)
        );

        assertTrue(ex.getMessage().contains("QUALIFICATION_INFO_ERROR"));
    }

    @Test
    void shouldThrowWhenPartyTypeIsCompanyId() {
        when(enrichment.getSide()).thenReturn("CREDIT");
        when(paymentInfo.getPartyIdType()).thenReturn("CompanyId");

        ValidationException ex = assertThrows(
                ValidationException.class,
                () -> QualificationValidation.qualificationValidation(request, header, props)
        );

        assertTrue(ex.getMessage().contains("PARTY_TYPE_ID_NOT_ALLOWED"));
    }

    @Test
    void shouldCallPaymentInfoValidationWhenAllValid() {
        try (MockedStatic<PaymentInfoValidation> piv = mockStatic(PaymentInfoValidation.class)) {
            when(enrichment.getSide()).thenReturn("DEBIT");

            assertDoesNotThrow(() ->
                    QualificationValidation.qualificationValidation(request, header, props));

            piv.verify(() -> PaymentInfoValidation.validatePaymentInfoPayload(
                    eq(request.getQualification().getEnrichment().getSide()),
                    eq(request.getPaymentInfo()),
                    eq(header),
                    eq(props)
            ), times(1));
        }
    }
}