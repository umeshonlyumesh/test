import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { MatTableDataSource, MatSort, MatPaginator } from '@angular/material';
import { of, throwError } from 'rxjs';
import { YourComponent } from './your-component.component';
import { AvsService } from './avs.service';

describe('YourComponent', () => {
  let component: YourComponent;
  let fixture: ComponentFixture<YourComponent>;
  let avsService: jasmine.SpyObj<AvsService>;
  let mockSort: jasmine.SpyObj<MatSort>;
  let mockPaginator: jasmine.SpyObj<MatPaginator>;

  const mockCompanyData = {
    body: {
      data: [
        { id: 1, name: 'Company A' },
        { id: 2, name: 'Company B' }
      ]
    }
  };

  beforeEach(() => {
    // Create spy objects
    avsService = jasmine.createSpyObj('AvsService', ['getCompanies']);
    mockSort = jasmine.createSpyObj('MatSort', ['']);
    mockPaginator = jasmine.createSpyObj('MatPaginator', ['']);

    TestBed.configureTestingModule({
      declarations: [YourComponent],
      providers: [
        { provide: AvsService, useValue: avsService }
      ]
    });

    fixture = TestBed.createComponent(YourComponent);
    component = fixture.componentInstance;
    
    // Assign mock sort and paginator
    component.sort = mockSort;
    component.paginator = mockPaginator;
  });

  it('should initialize loader and hide response when loading', () => {
    // Arrange
    avsService.getCompanies.and.returnValue(of(mockCompanyData));

    // Act
    component.loadCompanyEnrollments();

    // Assert
    expect(component.showLoader).toBeTrue();
    expect(component.isShowResponse).toBeFalse();
  });

  it('should set company enrollments and initialize table on success', fakeAsync(() => {
    // Arrange
    avsService.getCompanies.and.returnValue(of(mockCompanyData));

    // Act
    component.loadCompanyEnrollments();
    tick(); // Simulate async completion

    // Assert
    expect(component.companyEnrollments).toEqual(mockCompanyData.body.data);
    expect(component.initialCompanyEnrollments).toEqual(mockCompanyData.body.data);
    expect(component.dataSource).toBeInstanceOf(MatTableDataSource);
    expect(component.dataSource.data).toEqual(mockCompanyData.body.data);
    expect(component.dataSource.sort).toBe(mockSort);
    expect(component.dataSource.paginator).toBe(mockPaginator);
    expect(component.isShowResponse).toBeTrue();
    expect(component.isResponseSuccess).toBeTrue();
    expect(component.showLoader).toBeFalse();
  }));

  it('should handle error response', fakeAsync(() => {
    // Arrange
    const errorResponse = new Error('API Error');
    avsService.getCompanies.and.returnValue(throwError(errorResponse));

    // Spy on console.error to verify error handling
    spyOn(console, 'error');

    // Act
    component.loadCompanyEnrollments();
    tick(); // Simulate async completion

    // Assert
    expect(component.showLoader).toBeFalse();
    expect(component.isShowResponse).toBeTrue();
    expect(component.isResponseSuccess).toBeFalse();
    expect(console.error).toHaveBeenCalledWith('Error loading company enrollments:', errorResponse);
  }));

  it('should maintain separate references for companyEnrollments and initialCompanyEnrollments', fakeAsync(() => {
    // Arrange
    avsService.getCompanies.and.returnValue(of(mockCompanyData));

    // Act
    component.loadCompanyEnrollments();
    tick();

    // Modify the companyEnrollments array
    component.companyEnrollments.push({ id: 3, name: 'Company C' });

    // Assert
    expect(component.companyEnrollments.length).toBe(3);
    expect(component.initialCompanyEnrollments.length).toBe(2);
    expect(component.initialCompanyEnrollments).toEqual(mockCompanyData.body.data);
  }));

  it('should properly initialize MatTableDataSource with correct data', fakeAsync(() => {
    // Arrange
    avsService.getCompanies.and.returnValue(of(mockCompanyData));

    // Act
    component.loadCompanyEnrollments();
    tick();

    // Assert
    expect(component.dataSource.data).toEqual(mockCompanyData.body.data);
    expect(component.dataSource.sort).toBeDefined();
    expect(component.dataSource.paginator).toBeDefined();
  }));
});
